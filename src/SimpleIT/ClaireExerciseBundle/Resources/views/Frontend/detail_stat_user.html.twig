<table class="table table-bordered">
    <thead>
        <th colspan="2">Étudiant</th>
        <th colspan="2">Username</th>
    </thead>
    <tr>
        <td class="td-stat" colspan="2">{{stats.user.lastName}}  {{stats.user.firstName}}</td>
        <td class="td-stat" colspan="2">{{stats.user.username}}</td>
    </tr>
    <thead>
        <th class="td-stat" colspan="4">Vue dans le temps des notes obtenues par l'étudiant</th>
    </thead>
    <tr class="active">
        <td colspan="4" id="timeline_chart"></td>
    </tr>
    <thead>
        <th>Premier exercice généré</th>
        <th>Dernier exercice généré</th>
        <th>Première réponse soumise</th>
        <th>Dernière réponse soumise</th>
    </thead>
    <tr>
        <td class="td-stat">{{stats.firstDate}}</td>
        <td class="td-stat">{{stats.lastDate}}</td>
        <td class="td-stat">{{stats.firstDate2}}</td>
        <td class="td-stat">{{stats.lastDate2}}</td>
    </tr>
    <tr>
        <td class="td-stat" colspan="2">Nombre total d'exercices générés : {{stats.count1}}</td>
        <td class="td-stat" colspan="2">Nombre total de réponses soumises : {{stats.count2}}</td>
    </tr>
    <thead>
        <th class="td-stat" colspan="4">
            Répartition globale des notes de l'élève dans le dossier {{directory.name}}
        </th>
    </thead>
    <tr class="active">
        <td id="barplot_chart" colspan="4">
            {% if json == null %}
                Il n'y a pas de notes pour cet étudiant dans ce répertoire
            {% endif %}
        </td>
    </tr>
    {% if json_sunburst != null %}
        <thead>
            <th class="td-stat" colspan="4">
                Liste des sous dossiers de {{directory.name}}
            </th>
        </thead>
        <tr class="active">
            <td id="barplot_chart_directory" colspan="4"></td>
        </tr>
        <thead>
            <th class="td-stat" colspan="4" id="model"></th>
        </thead>
        <tr class="active">
            <td id="barplot_chart_model" colspan="4"></td>
        </tr>
    {% endif %}
</table>
<script>
    function Sunburst(selector, data, type, _color) {
        if(data.length == 0) return;
        var color = d3.scaleOrdinal(d3.schemeCategory20);
        // set the dimensions and margins of the graph
        var margin = {top: 200, right: 0, bottom: 200, left: 0},
            width = 1200 - margin.left - margin.right,
            height = 800 - margin.top - margin.bottom,
            innerRadius = 50,
            outerRadius = Math.min(width, height) / 2;   // the outerRadius goes from the middle of the SVG area to the border

        // append the svg object
        var svg = d3.select("#"+selector)
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform", "translate(" + (width / 2 + margin.left) + "," + (height / 2 + margin.top) + ")");

            function scaleRadial() {
              var domain = [0, 1],
                  range = [0, 1];
              function scale(x) {
                var r0 = range[0] * range[0], r1 = range[1] * range[1];
                return Math.sqrt((x - domain[0]) / (domain[1] - domain[0]) * (r1 - r0) + r0);
              }

              scale.domain = function(_) {
                return arguments.length ? (domain = [+_[0], +_[1]], scale) : domain.slice();
              };

              scale.range = function(_) {
                return arguments.length ? (range = [+_[0], +_[1]], scale) : range.slice();
              };

              scale.ticks = function(count) {
                return d3.scaleLinear().domain(domain).ticks(count);
              };

              scale.tickFormat = function(count, specifier) {
                return d3.scaleLinear().domain(domain).tickFormat(count, specifier);
              };

              return scale;
            }
          // Scales
          var x = d3.scaleBand()
              .range([0, 2 * Math.PI])    // X axis goes from 0 to 2pi = all around the circle. If I stop at 1Pi, it will be around a half circle
              .align(0)                  // This does nothing
              .domain(data.map(function(d) { return d.name; })); // The domain of the X axis is the list of states.
          var y = scaleRadial()
              .range([innerRadius, outerRadius])   // Domain will be define later.
              .domain([0, 100]); // Domain of Y is from 0 to the max seen in the data

          var tooltip = d3.select("#"+selector)
            .append("div")
              .style("opacity", 0)
              .attr("class", "tooltip")
              .style("background-color", "black")
              .style("border-radius", "5px")
              .style("padding", "10px")
              .style("color", "white")

          var showTooltip = function(d) {
              var x = d3.event.pageX
              var y = d3.event.pageY
            tooltip
              .transition()
              .duration(200)
            tooltip
              .style("opacity", 1)
              .style("left", (x+30) + "px")
              .style("top", (y+30) + "px")

              switch(type){
                  case 0:
                      tooltip.html(
                            "Répertoire : " + d.directory + '<br>' +
                            "Modèle : " + d.name + '<br>' +
                            "Note moyenne : " + (Math.round(d.mark * 100) / 100) + '<br>' +
                            "Nombre de réponses soumises : " + d.total
                        )
                  break;
                  case 1:
                      d3.select(this).style("cursor", "pointer");
                      tooltip.html(
                            "Répertoire : " + d.name + '<br>' +
                            "Note moyenne : " + (Math.round(d.mark * 100) / 100) + '<br>' +
                            "Nombre de réponses soumises : " + d.total
                        )
                  break;
                  case 2:
                      tooltip.html(
                            "Modèle : " + d.name + '<br>' +
                            "Note moyenne : " + (Math.round(d.mark * 100) / 100) + '<br>' +
                            "Nombre de réponses soumises : " + d.total
                        )
                  break;
              }
          }
          var moveTooltip = function(d) {
              var x = d3.event.pageX
              var y = d3.event.pageY
            tooltip
              .style("left", (x+30) + "px")
              .style("top", (y+30) + "px")
          }
          var hideTooltip = function(d) {
            tooltip
              .transition()
              .duration(200)
              .style("opacity", 0)
            d3.select(this).style("cursor", "default");
          }
          var clickTooltip = function(d) {
              if(type !== 1) return;
              document.getElementById('model').innerHTML=
                `Liste des modèles de ${d.name}`
              ;

              var element = document.getElementById("barplot_chart_model");
                while (element.firstChild) {
                  element.removeChild(element.firstChild);
                }

              Sunburst("barplot_chart_model", d.models, 2, color(d.id));
              window.scrollBy(0,850);
          }
          // Add the bars
          svg.append("g")
            .selectAll("path")
            .data(data)
            .enter()
            .append("path")
              .attr("fill", d => (type !== 2 ? color(d.id) : _color))
              .attr("d", d3.arc()     // imagine your doing a part of a donut plot
                  .innerRadius(innerRadius)
                  .outerRadius(function(d) { return y(d['mark']|1); })
                  .startAngle(function(d) { return x(d.name); })
                  .endAngle(function(d) { return x(d.name) + x.bandwidth(); })
                  .padAngle(0.01)
                  .padRadius(innerRadius))
          .on("mouseover", showTooltip )
          .on("mousemove", moveTooltip )
          .on("mouseleave", hideTooltip )
          .on("click", clickTooltip )

          // Add the labels
          svg.append("g")
              .selectAll("g")
              .data(data)
              .enter()
              .append("g")
                .attr("text-anchor", function(d) { return (x(d.name) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "end" : "start"; })
                .attr("transform", function(d) { return "rotate(" + ((x(d.name) + x.bandwidth() / 2) * 180 / Math.PI - 90) + ")"+"translate(" + (y(d['mark'])+10) + ",0)";})
              .append("text")
                .text(function(d){return(d.name)})
                .attr("transform", function(d) { return (x(d.name) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "rotate(180)" : "rotate(0)"; })
                .style("font-size", "13px")
                .attr("alignment-baseline", "middle")

    }
    data = {{json|json_encode()|raw}};
    Sunburst("barplot_chart", data, 0, null);

    data = {{json_sunburst|json_encode()|raw}};
    Sunburst("barplot_chart_directory", data, 1, null);

    function Timeline(selector, data){

        let types = data
            .filter(d => d.length !== 0)
            .map(d => d[0].directory);
            console.log(types);

        let csv = data.flat();

        (function() {
          d3.timeline = function() {
            var timelines = [];
            var dateAccessor = function (d) {return new Date(d)};
            var processedTimelines = [];
            var startAccessor = function (d) {return d.start};
            var endAccessor = function (d) {return d.end};
            var size = [1180,100];
            var timelineExtent = [-Infinity, Infinity];
            var setExtent = [];
            var displayScale = d3.scaleLinear();
            var swimlanes = [];
            var padding = 0;
            var fixedExtent = false;
            var maximumHeight = Infinity;

            function processTimelines() {
            	timelines.forEach(function (band) {
            		var projectedBand = {};
                    for (var x in band) {
                        if (band.hasOwnProperty(x)) {
                            projectedBand[x] = band[x];
                        }
                    }
            		projectedBand.start = dateAccessor(startAccessor(band));
            		projectedBand.end = dateAccessor(endAccessor(band));
            		projectedBand.lane = 0;
            		processedTimelines.push(projectedBand);
            	});
            }

            function projectTimelines() {
                if (fixedExtent === false) {
                    var minStart = d3.min(processedTimelines, function (d) {return d.start});
                    var maxEnd = d3.max(processedTimelines, function (d) {return d.end});
                    timelineExtent = [minStart,maxEnd];
                }
                else {
                    timelineExtent = [dateAccessor(setExtent[0]), dateAccessor(setExtent[1])];
                }

                displayScale.domain(timelineExtent).range([0,size[0]]);

                processedTimelines.forEach(function (band) {
                    band.originalStart = band.start;
                    band.originalEnd = band.end;
                    band.start = displayScale(band.start);
                    band.end = displayScale(band.end);
                });
            }

            function fitsIn(lane, band) {
            	if (lane.end < band.start || lane.start > band.end) {
            		return true;
            	}
            	var filteredLane = lane.filter(function (d) {return d.start <= band.end && d.end >= band.start});
            	if (filteredLane.length === 0) {
            		return true;
            	}
            	return false;
            }

            function findlane(band) {
            	//make the first array
            	if (swimlanes[0] === undefined) {
            		swimlanes[0] = [band];
            		return;
            	}
            	var l = swimlanes.length - 1;
            	var x = 0;

            	while (x <= l) {
            		if (fitsIn(swimlanes[x], band)) {
            			swimlanes[x].push(band);
            			return;
            		}
            		x++;
            	}
            	swimlanes[x] = [band];
            	return;
            }

            function timeline(data) {
            	if (!arguments.length) return timeline;

            	timelines = data;

            	processedTimelines = [];
            	swimlanes = [];

            	processTimelines();
                projectTimelines();


            	processedTimelines.forEach(function (band) {
            		findlane(band);
            	});

            	var height = size[1] / swimlanes.length;
            	height = Math.min(height, maximumHeight);

            	swimlanes.forEach(function (lane, i) {
            		lane.forEach(function (band) {
            			band.y = i * (height);
            			band.dy = height - padding;
            			band.lane = i;
            		});
            	});

            	return processedTimelines;
            }

            timeline.dateFormat = function (_x) {
        	     if (!arguments.length) return dateAccessor;
        	     dateAccessor = _x;
            	return timeline;
            }

            timeline.bandStart = function (_x) {
        	     if (!arguments.length) return startAccessor;
        	     startAccessor = _x;
            	return timeline;
            }

            timeline.bandEnd = function (_x) {
        	     if (!arguments.length) return endAccessor;
        	     endAccessor = _x;
            	return timeline;
            }

            timeline.size = function (_x) {
        	     if (!arguments.length) return size;
        	     size = _x;
            	return timeline;
            }

            timeline.padding = function (_x) {
        	     if (!arguments.length) return padding;
        	     padding = _x;
            	return timeline;
            }

            timeline.extent = function (_x) {
        	    if (!arguments.length) return timelineExtent;
        	    	fixedExtent = true;
        	    	setExtent = _x;
        	    	if (_x.length === 0) {
        	    		fixedExtent = false;
        	    	}
            	return timeline;
            }

            timeline.maxBandHeight = function (_x) {
        	    if (!arguments.length) return maximumHeight;
        	    	maximumHeight = _x;
            	return timeline;
            }

            return timeline;
        }
        })();
        var timeline = d3.timeline()
          .extent(d3.extent(csv.map(d=>d.start)))
          .padding(3)
          .maxBandHeight(20);
          let colorScale = d3.scaleOrdinal(d3.schemeCategory20);

        let x = d3
            .scaleTime()
            .range([0, 1200])
            .domain(d3.extent(csv.map(d => new Date(d.date))));

        var svg = d3.select("#"+selector)
          .append("svg")
            .attr("width", 1200)
            .attr("height", 90 * types.length)

        svg.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(0," + (types.length * 90 - 20) + ")")
            .call(d3.axisBottom(x).tickFormat(d3.timeFormat("%d/%m/%Y")))

        types.forEach(function (type, i) {
          onlyThisType = csv.filter(function(d) {return d.directory === type});

          let theseBands = timeline(onlyThisType);
          var tooltip = d3.select("#"+selector)
            .append("div")
              .style("opacity", 0)
              .attr("class", "tooltip")
              .style("background-color", "black")
              .style("border-radius", "5px")
              .style("padding", "10px")
              .style("color", "white")

          var showTooltip = function(d) {
              var x = d3.event.pageX
              var y = d3.event.pageY
            tooltip
              .transition()
              .duration(200)
            tooltip
              .style("opacity", 1)
              .style("left", (x+30) + "px")
              .style("top", (y+30) + "px")
              var formatD = d3.timeFormat("%d/%m/%Y");
              var formatH = d3.timeFormat("%H:%M:%S");
              tooltip.html(
                  "Date : " + formatD(new Date(d.date)) + '<br>' +
                  "Heure : " + formatH(new Date(d.date)) + '<br>' +
                  "Note : " + (Math.round(d.value * 100) / 100) + '<br>' +
                  "Modèle : " + d.name + '<br>'
              )
          }
          var hideTooltip = function(d) {
            tooltip
              .transition()
              .duration(200)
              .style("opacity", 0)
            d3.select(this).style("cursor", "default");
          }

          svg.append("g")
          .attr("transform", "translate(10," + (35 + (i * 90)) + ")")
          .selectAll("rect")
          .data(theseBands)
          .enter()
          .append("rect")
          .attr("rx", 2)
          .attr("x", function (d) {return d.start})
          .attr("y", 0)
          .attr("height", function (d) {return d.dy})
          .attr("width", 5)
          .style("fill", function (d) {
              if(d.value > 66) return "green";
              else if(d.value <= 33) return "red";
              else return "orange";
          })
          .on("mouseover", showTooltip)
          .on("mouseout", hideTooltip)

          svg.append("rect")
          .attr("rx", 2)
          .attr("x", 0)
          .attr("y", 55 + (i * 90))
          .attr("height", 1)
          .attr("width", 1200)
          .style("fill", "#424C47")

          svg.append("rect")
          .style("fill", colorScale(i))
          .attr("y", 5 + (i * 90))
          .attr("x", 20)
          .attr("height", 20)
          .attr("width", 20)

          svg.append("text")
          .text(type)
          .attr("y", 20 + (i * 90))
          .attr("x", 50)

        })
    }
    data = {{json_timeline|json_encode()|raw}};
    Timeline("timeline_chart", data);

</script>
